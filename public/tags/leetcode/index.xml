<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>leetcode on Even - A super concise theme for Hugo</title>
    <link>https://Jeffery18-hub.github.io/tags/leetcode/</link>
    <description>Recent content in leetcode on Even - A super concise theme for Hugo</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Wed, 22 Nov 2023 22:52:45 -0700</lastBuildDate><atom:link href="https://Jeffery18-hub.github.io/tags/leetcode/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Leetcode 198.House Robber</title>
      <link>https://Jeffery18-hub.github.io/post/leetcode-198-dot-house-robber/</link>
      <pubDate>Wed, 22 Nov 2023 22:52:45 -0700</pubDate>
      
      <guid>https://Jeffery18-hub.github.io/post/leetcode-198-dot-house-robber/</guid>
      <description>Problem Description You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security systems connected and it will automatically contact the police if two adjacent houses were broken into on the same night. Given an integer array nums representing the amount of money of</description>
    </item>
    
    <item>
      <title>0-1 Knapsack Problem</title>
      <link>https://Jeffery18-hub.github.io/post/0-1-knapsack-problem/</link>
      <pubDate>Sun, 01 Oct 2023 23:17:32 -0600</pubDate>
      
      <guid>https://Jeffery18-hub.github.io/post/0-1-knapsack-problem/</guid>
      <description>Introduction to the 0-1 Knapsack Problem The 0-1 Knapsack problem is a classic optimization problem. Imagine you have a bag with a certain weight capacity, and you have a set of items, each with its own weight and value. The problem is to determine which items to include in the bag to maximize its total value without exceeding its weight capacity. Brute Force The simplest way to tackle the 0-1</description>
    </item>
    
    <item>
      <title>Recursively Traverse a Binary Tree</title>
      <link>https://Jeffery18-hub.github.io/post/recursively-traverse-a-binary-tree/</link>
      <pubDate>Sun, 13 Aug 2023 12:22:51 -0600</pubDate>
      
      <guid>https://Jeffery18-hub.github.io/post/recursively-traverse-a-binary-tree/</guid>
      <description>Traversal Order A binary tree offers three primary traversal methods: Pre-order, In-order, and Post-order. 1 2 3 4 5 6 1 / \ 2 3 / \ \ 4 5 6 pre-order: 1-&amp;gt;2-&amp;gt;4-&amp;gt;5-&amp;gt;3-&amp;gt;6 in-order: 4-&amp;gt;2-&amp;gt;5-&amp;gt;1-&amp;gt;3-&amp;gt;6 post-prder: 4-&amp;gt;5-&amp;gt;2-&amp;gt;6-&amp;gt;3-&amp;gt;1 The root node appears first in pre-order traversal and last in post-order traversal. Leveraging this characteristic, one can uniquely construct a binary tree when provided with combinations of preorder-inorder or postorder-inorder arrays. Note</description>
    </item>
    
  </channel>
</rss>

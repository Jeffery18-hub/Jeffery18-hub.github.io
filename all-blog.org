#+hugo_base_dir: ~/blog/
#+hugo_section: post
#+hugo_auto_set_lastmod: t
#+hugo_custom_front_matter: :author "Jeffery@slc"

* Blog Ideas

    
** finished TODO 操作系统是如何被加载的？
:PROPERTIES:
:EXPORT_FILE_NAME: 操作系统是如何被加载的
:END:

- State "finished"   from              [2023-03-06 Mon 10:58]
最近在学习计算机操作系统，其知识结构庞杂，难度对于我来说挺大的，深感很有必要写点笔记，思考、总结、输出也许方能领会其中。第一篇文章就从一个简单的角度入手.

计算机通电后，操作系统是如何开始运行的？

首先，关注下计算机主板（mother board）上四个关键硬件：BIOS ，主存（RAM），硬盘（Hard Disk），CPU：<br>
BIOS：Basic Input/Output System，主板上的一个固件程序（Firmware)，通常是预装在主板上的，计算机通电之后就是靠他开始第一步的工作。
RAM：这个大家都比较熟悉，不同的程序运行在主存上不同的地址空间。
HD：硬盘的第一个扇区一共才512个字节，存储了一个小玩意叫BootLoader，就是靠他来加载操作系统内核的。
CPU：下图可以看到CPU里我只画了寄存器registers，常用的寄存器包括AX、DX、stack pointer、instruction pointer等。

![os.png](/images/os.png)

*** 加载BIOS
主板制造商会将固件程序编译成二进制文件，写入BIOS芯片中（固件程序一般是用汇编语言编写）。计算机通电启动时，BIOS会被加载到主存上，自动执行一系列固定程序来检测计算机硬件是否正常，例如检测内存、硬盘、键盘、鼠标等外部设备，并且根据预设的启动顺序查找硬盘上的引导程序（boot loader）。
CPU的指令寄存器会指向主存上BIOS指令的起始地址0xFFFF0（上图红色虚线指向的第一个位置）。当CPU执行一条指令时，它会将指令指针自增以指向下一条指令的地址。

*** 加载BootLoader
BootLoader程序加载到主存上执行，执行起始地址为0x7C00（上图红色虚线指向的第二个位置）。
BootLoader主要负责在计算机启动时加载操作系统内核（kernel）到内存中，并将控制权转交给内核，使其能够开始执行。所以，开发操作系统，编写boot代码是绕不开的第一步。

*** 加载操作系统内核
BootLoader将硬盘上存储的操作系统内核加载到相应的的内存地址空间。执行起始地址为0x100000（上图红色虚线指向的第三个位置）。
操作系统内核在被加载到内存之前，需要经过解压缩和初始化等一系列操作。解压缩是因为操作系统内核一般包含大量指令和数据，压缩存储在硬盘相对节省空间；

初始化包括以下几个方面：<br>
1. 初始化CPU：内核会对CPU进行初始化，包括设置CPU的寄存器、设置中断处理程序（interupt）和系统调用处理程序（sys call）等，以便在操作系统运行时能够调用它们。
2. 初始化内存：内核会对内存进行初始化，包括检测可用内存、分配内存空间等。在初始化过程中，内核还会设置页表（page table）等，以便操作系统能够正确地访问内存。
3. 初始化设备驱动程序：内核会加载并初始化设备驱动程序，以便操作系统能够访问硬件设备。在初始化过程中，内核会从文件系统中加载设备驱动程序，并将它们链接到内核中（动态链接）。
4. 加载系统模块：在初始化过程中，内核会从文件系统中加载一些必要的模块，并将它们链接到内核中。这些模块包括文件系统模块、网络模块、安全模块等，它们可以提供一些必要的服务，例如文件系统访问、网络通信等。
5. 启动用户空间初始化程序：内核初始化完成后，会启动用户空间初始化程序（user space initialization program），它负责启动其他系统进程，并提供一些必要的服务（例如网络、文件系统等）。

完成上述操作后，内核会将控制权转交给用户空间初始化程序，从而完成操作系统的启动。

在Windows操作系统中，用户空间初始化程序是Windows Explorer（或称为资源管理器）。Windows Explorer是一个图形化用户界面，它提供了用户在Windows系统中的桌面环境，并且负责启动其他系统进程和服务，例如Windows服务、网络服务等。

*** 结尾
本文个别地方因为知识局限就没有展开，随着学习的深入以后有机会再探讨。

*** 参考
1. 柏林工业大学 Viktor Engelmann 他的个人主页http://www.algorithman.de/Autor/index.php<br>
2. 清华大学 陈渝 操作系统原理课程 B站有很多他的课程视频<br>
3. intel官方网站：https://www.intel.com/content/www/us/en/gaming/resources/how-to-update-bios.html

   
** finished Recursively Traverse a Binary Tree
:PROPERTIES:
:EXPORT_FILE_NAME: recursively-traverse-a-binary-tree
:END:

*** Traversal Order
A binary tree offers three primary traversal methods: Pre-order, In-order, and Post-order.

#+BEGIN_EXAMPLE

     1
    / \
   2   3
  / \   \
 4  5    6
#+END_EXAMPLE

pre-order: 1->2->4->5->3->6  
in-order: 4->2->5->1->3->6  
post-prder: 4->5->2->6->3->1  

The root node appears first in pre-order traversal and last in post-order traversal.
Leveraging this characteristic, one can uniquely construct a binary tree when provided with combinations of preorder-inorder or postorder-inorder arrays.
Note that combinations of preorder-postorder arrays aren't sufficient for unique tree construction.

*** Traverse Recursively
Starting from the root node, the natural flow in a recursive traversal aligns with a pre-order traversal.
#+BEGIN_SRC java
  void traverse(TreeNode root) {
      //base case
      if(root == null) return;
      traverse(root.left); // left subtree
      traverse(root.right); // right subtree
      return;
  }
#+END_SRC


The code above just traverses the binary tree without performing any additional operations. Let’s enhance this by printing the node values.
#+BEGIN_SRC java
  void traverse(TreeNode root) {
      if(root == null) return;
      System.out.println(root.val); 
      traverse(root.left);
      traverse(root.right);
      return;
  }
#+END_SRC

Here, during traversal, each node's value is printed out. This is indicative of pre-order traversal where the node's value is processed before its left and right children.

Let's illustrate the methods to traverse and print node values using in-order and post-order approaches.
#+BEGIN_SRC java
  // in-order
  void traverse(TreeNode root) {
      if(root == null) return;
      traverse(root.left);
      System.out.println(root.val); // handling in the mid of left and right
      traverse(root.right);
      return;
  }
#+END_SRC


#+BEGIN_SRC java
  // post-order
  void traverse(TreeNode root) {
      if(root == null) return;
      traverse(root.left);
      traverse(root.right);
      System.out.println(root.val); // handling at last
      return;
  }
#+END_SRC


*** Backtracking
For in-order and post-order traversal, the timing of the node processing varies. The node processing occurs during the backtracking phase.

Example of postorder traversal

![tree2.png](/images/tree2.png)


The red dotted lines represent the backtracking, and the green numbers signify the sequence of steps:

Steps 1.1 to 1.3: Traverse left until the leftmost leaf node (value 4).
Steps 1.4 to 1.6: Leaf node's left and right children are null, so return to the leaf node and print the value 4.
Step 1.7: Return to node 2.
Step 1.8: Traverse to the right child node (value 5).
Steps 1.9 to 2.2: As both the left and right children of the leaf node are null, return to the leaf node and print the value 5.
Step 2.3: Return to node 2 and print its value, resulting in the post-order output 4->5->2 for the left subtree.

This is just a segment of the recursive process, providing my understanding into the mechanics of tree traversal when gruelingly grinding on LeetCode.
** finished   坎昆之旅
:PROPERTIES:
:EXPORT_FILE_NAME: 坎昆之旅
:END:

- State "finished"   from              [2023-09-23 Sat 12:15]
多年之后再次来到墨西哥，莫名有点感动，当年离开的时候和当地的朋友一起吃饭，朋友说我们以后应该很难再见面了。
这次带老婆来墨国，最终还是选择了坎昆，毕竟是这里最有名的旅游城市，作为探索这个国家的第一站是再适合不过的。

*** 炙热的天气
夏天的坎昆，阳光炙热，海风咸湿。游船上白人夫妻难以应对紫外线的照射，相互给对方搔挠后背。多年前我因为数月在墨西哥晃荡，小臂晒出了皮疹，老娘帮我敷了淡盐水，居然神奇的治好了。
这次在老婆的敦促下，充分做好了防晒的工作，皮肤上除了再次烙上了阳光的颜色，并无大碍。炽烈的阳光搭配上加勒比的海水，倒像是一杯蓝色鸡尾酒的杯口，点缀着一小块橘片，增添了酒的风味。

*** 女人岛
对于女人岛的记忆已经模糊，当年远远地坐在礁石上拍了一张游客照。这次过来以为能做个不错的导游，但是发现时日太久，竟然还像第一次过来的
游客，有点手足无措。下船上岛，和老婆随机选择了一家餐馆，裹着椰肉的炸虾味道不错，但是我最喜欢的洛神花茶实在潦草敷衍。吃完饭，我们来到小岛北端的人气海滩Playa Norte。
沙滩细腻的白过渡到清澈的浅绿，再一层层的向远处深邃的蔚蓝推开过去。

我是比较畏水的，但也忍不住和老婆下水泡了泡澡，炎热的天气泡在海水中舒适惬意，玩累再回到沙滩椅子上晒晒太阳。
待海边玩得尽兴，我们开着高尔夫车从小岛的北端一路向南，相比较北边海滩的温柔，南边风景多了一份刚烈。海水有力地拍打在礁石上，四散成细碎的泡沫，涛声阵阵，让人不禁感到心潮澎湃。

加勒比海的蜥蜴木讷可爱得出现在游客面前，周身褐色，跟岩壁融为一体，看到我们过来，并没有离开，仿佛在告诉我们他们才是这里的主人。

傍晚，巨型的玛雅人像沐浴在通红的夕阳中，几千年前的历史与谁人说？

*** 加勒比的乐园
早早起床，我们乘坐大巴前往xcarlet乐园。我多少有点忐忑，园区里有个地下溶洞游泳的项目，老婆应该很想玩，但我又比较害怕。

凌乱的思绪在进园的第一个项目中被熨烫得服服帖帖，我们开着越野车穿梭于热带雨林中，坑坑洼洼的土路颠簸走了平日的烦恼，原始的环境陡增了驾驶的乐趣。
地下溶洞没有我预设的那般可怕，老婆考虑到我的感受，并没有在溶洞水中游泳，以划船及水中徒步取而代之，水中影影绰绰能够看到一些小鱼，清凉的溶洞水让早起的我们精神更加振奋。

午饭期间，绿色的大蜥蜴时不时地得过来向游客展示自己的呆萌气质，蓝色的小鸟总是在人们离开餐桌时飞过来享受人类的残羹冷炙。

*** 导游Omar
为了更好的了解玛雅和阿兹特克文明，我们请了当地的导游，Omar一早驱车过来接上我们，第一站便去了玛雅金字塔。金字塔由灰白色的巨石组成，层层垒上去，塔顶是一座羽蛇神庙。金字塔一共四面，每面91个台阶，
算上塔顶神庙一共365级台阶。现在的金字塔已经不允许游客沿着台阶一级一级爬上去了，只能在四周观察。

上次来玩，还很年轻，对于历史和文明似乎缺乏应有的兴趣，这次竟认真的听起了导游的讲解。“玛雅人”的竞技中，胜利者被献祭；金字塔的几何设计使得太阳落山时分，金字塔一面投射出蛇影；在金字塔南面拍拍手，回声阵阵。

大概10点多游玩结束，这时载满游客的大巴车排着队往景区进发，Omar为能成功避开人群，洋洋得意，讥笑别人为失败者。在某种程度上他可能是个成功者，早年在美国开
卡车，顺便学习了英语，荣归故里后从事旅游行业，貌似干得风生水起。他的老婆是个玛雅人，会说古老的玛雅语言，有着亚洲人年轻的容颜，用他的话说是years eater。从他的身上我能看出来墨西哥人对于生死的达观。
不久之前，他的一个女儿因病离世，但Omar看起来并没有沉浸在失去爱女的悲痛中，还是有说有笑，他对我说，女儿虽然去世了，但她还爱着我。

下午，导游带我们去了一个天坑（cenote，天然水井），坑很大，深蓝的井水神秘平静，人还没下水，便联想到下面的万丈深渊。我们换上救生衣，带着一丝丝忐忑下水了，我还是谨慎地只敢在岸边踩着石头划划水，看看水中巴掌大点的
鲶鱼游来游去。老婆水性好些，游了个来回。

午饭是在玛雅村落中一户人家中解决的，这户人家的主人好像是Omar的老相识了，之前在餐厅打工，在Omar的鼓励下回乡创业，搞起了“乡村经济”。我们二人对于这顿午饭很是满意，现烤的猪肋排香嫩多汁，村民自制的南瓜籽酱给原本
就美味的taco增添了更多的香气。

最后一天，我俩在酒店的海滩静静地躺了一下午，听听海浪，晒晒太阳，海天一线，安神去乏。坎昆之旅会是未来墨国探索的又一个新的开始。

** finished 0-1 Knapsack Problem
:PROPERTIES:
:EXPORT_FILE_NAME: 0-1-knapsack-problem
:END:


- State "finished"   from              [2023-10-01 Sun 23:15]
*** Introduction to the 0-1 Knapsack Problem

The 0-1 Knapsack problem is a classic optimization problem. Imagine you have a bag with a certain weight capacity, and you have a set of items, each with its own weight and value.
The problem is to determine which items to include in the bag to maximize its total value without exceeding its weight capacity.

*** Brute Force
The simplest way to tackle the 0-1 Knapsack problem is using a brute-force method. Here, we evaluate every possible combination of items:

For each item, we can either choose to include it in the bag or leave it out, leading to two choices for each item.
This decision-making can be visualized as a binary tree structure, where each node represents a choice, and each level of the tree corresponds to an item.
Given n items, the total number of combinations is 2^n, leading to a time complexity of O(2^n).

#+BEGIN_SRC java
       class Solution_bruteforce {
	  int maxValue = 0;
	  int[] weights;
	  int[] values;
	  int bagCapacity;

	   public void bruteforce(int[] weights, int[] values, int bagCapacity) {
	      this.weights = weights;
	      this.values = values;
	      this.bagCapacity = bagCapacity;
	      dfs(0, 0, 0);
	      System.out.println(maxValue);
	  }

	  private void dfs(int n, int curValue, int curWeight) {
	      //base case
	      if(curWeight > bagCapacity) return;

	      if(n == weights.length) {
		  maxValue = Math.max(maxValue, curValue);
		  return;
	      }

	      maxValue = Math.max(maxValue, curValue);

	      // choose the Nth item
	      dfs(n + 1,  curValue + values[n], curWeight + weights[n]);
	      // not choose the nth item
	      dfs(n + 1, curValue , curWeight);
	  }
      }

#+END_SRC

*** Dynamic Programming with 2D dp array
Dynamic Programming (DP) offers a more efficient way to solve the problem. Instead of recalculating results, we store them in a table (usually a 2D array) and refer back to them when needed:

dp[i][j] denotes the maximum value that can be obtained using the first i items, considering a bag capacity of j.
To populate this table, we use previously computed values, building up the solution incrementally.
This method reduces the time complexity to O(m*n), where m is the number of items and n is the bag's capacity.


#+BEGIN_SRC  java
  class Solution_dp {
      public void dp(int[] weights, int[] values, int bagCapacity) {
	  int[][] dp = new int[weights.length][bagCapacity + 1]; // means max value can be stored in bagCapacity

	  // init first column
	  for (int i = 0; i < weights.length; i++) {
	      dp[i][0] = 0;
	  }

	  // init first row
	  for (int j = 1; j <= bagCapacity; j++) {
	      dp[0][j] = (j >= weights[0]) ? values[0] : 0;
	  }

	  for (int i = 1; i < weights.length; i++) {
	      for (int j = 1; j <= bagCapacity; j++) {
		  dp[i][j] = Math.max(dp[i - 1][j],
			  (j >= weights[i]) ? dp[i - 1][j - weights[i]] + values[i] : dp[i - 1][j]);
	      }
	  }

	  // print the dp array
	  for (int i = 0; i < weights.length; i++) {
	      for (int j = 0; j <= bagCapacity; j++) {
		  System.out.print(dp[i][j] + " ");
	      }
	      System.out.println();
	  }
      }
  }
#+END_SRC

*** Dynamic Programming with 1D dp array
Observing the 2D DP solution, a pattern emerges. The value in a cell only depends on values from the previous row( dp[i][j] = max( dp[i -1][j], dp[i - 1][j - weights[i]] + values[i]))) : 

This observation allows us to compress the 2D table into a 1D array, further reducing space complexity.
The idea is to process the items one by one, and for each item, iterate through the array in reverse (must do it in reverse order of weight, for not overwriting the previous state)), updating its values.

#+BEGIN_SRC java
   class Solution_dp_compress {
        public void dp_compress(int[] weights, int[] values, int bagCapacity){
            int[] dp = new int[bagCapacity + 1];
            int n = weights.length;
            // init dp
            for(int i = 0; i < n; i++) {
                dp[i] = 0;
            }

            for(int i = 0; i < n; i++) {
                for(int j = bagCapacity; j >=0; j--) {
                    dp[j] = Math.max(dp[j], (j - weights[i] >=0)? dp[j - weights[i]] + values[i]:0);
                }
            }
            System.out.println(dp[dp.length - 1]);
        }
    }

#+END_SRC

*** Test Results
#+BEGIN_SRC java
  public static void main(String[] args) {
	// three objects: 0, 1, 2
	int[] weights = { 1, 3, 4 };
	int[] values = { 15, 20, 30 };
	int bagCapacity = 4;

       Solution_bruteforce s2 = new Solution_bruteforce();
       s2.bruteforce(weights, values, bagCapacity);
       // result: 35


       Solution_dp s = new Solution_dp();
       s.dp(weights, values, bagCapacity);
       // print out:
       /*
	 0 15 15 15 15 
	 0 15 15 20 35 
	 0 15 15 20 35
       ,*/

       Solution_dp_compress s3 = new Solution_dp_compress();
       s3.dp_compress(weights, values, bagCapacity);
       // result: 35
  }

#+END_SRC


*** Leetcode 474. Ones and Zeroes
#+BEGIN_EXAMPLE
You are given an array of binary strings strs and two integers m and n.
Return the size of the largest subset of strs such that there are at most m 0's and n 1's in the subset.
A set x is a subset of a set y if all elements of x are also elements of y.

Example 1:
Input: strs = ["10","0001","111001","1","0"], m = 5, n = 3
Output: 4
Explanation: The largest subset with at most 5 0's and 3 1's is {"10", "0001", "1", "0"}, so the answer is 4.
Other valid but smaller subsets include {"0001", "1"} and {"10", "1", "0"}.
{"111001"} is an invalid subset because it contains 4 1's, greater than the maximum of 3.

#+END_EXAMPLE

The problem of selecting binary strings with a constraint on the number of zeros and ones is a twist on the 0-1 Knapsack problem:

Instead of a single weight capacity, we now have two: m for the number of zeros and n for the number of ones.
The 2D DP array dp[i][j] now represents the maximum number of strings that can be formed with i zeros and j ones..

#+BEGIN_SRC java
  class Solution {
    public int findMaxForm(String[] strs, int m, int n) {
        int[][] dp = new int[m + 1][n + 1];
        for(int i = 0; i < strs.length; i++) {
            int[] nums = getZerosNOnes(strs[i]);
            for(int j = m; j >=0; j--) {
                for(int k = n; k>=0; k--) {
                    int thisState = (j - nums[0] >= 0 && k - nums[1] >= 0)? dp[j - nums[0]][k - nums[1]] + 1 : 0; // if i is chosen, the size is incremented by one
                    dp[j][k] = Math.max(dp[j][k], thisState); // dynamic formula
                }
            }
        }

        return dp[m][n];
    }

    private int[] getZerosNOnes(String str) {
        int zeros = 0, ones = 0;
        for(char c : str.toCharArray()) {
            if(c == '0') {
                zeros++;
            }else{
                ones++;
            }
        }
        return new int[]{zeros, ones};
    }
}
#+END_SRC

** finished Three.js Fundamentals
:PROPERTIES:
:EXPORT_FILE_NAME: three-dot-js-fundamentals
:END:

- State "finished"   from              [2023-10-04 Wed 11:39]
This blog post is primarily intended to document my learning journey with three.js.
At its core, this framework is a JavaScript library built on top of WebGL, designed to help developers efficiently create 3D models and scenes.
Here are some fundamental concepts and code snippets:

*** Primary Classes
First, let's take a glance at the structural diagram:
![structure.png](/images/threejsBasics/structure.png)

**** Renderer
As seen from the above structural diagram, right at the top is the Renderer object.
The renderer is responsible for continuously rendering images to the browser's canvas.
It takes in a camera and a scene as its parameters. In essence, it renders (or draws) the portion of the 3D scene that
lies within the camera's frustum onto Ca canvas, presenting it as a 2D image.

**** Scene
The scene object is akin to a movie set. It contains actors, props, backgrounds, lights, and more.
However, it's crucial to note that the scene class and the camera class are paralleled.
There's no need to add the camera to the scene. Objects added to a scene, or the children of the scene, are positioned and oriented relative to their parent.

**** Camera
The camera object captures the scene. Its settings, such as the field of view, near position, and far position, can be adjusted.
![camera1.png](/images/threejsBasics/camera1.png)
This overhead view gives a clearer perspective on the relative positions of the camera and scene objects on the coordinate axes.
![camera2.png](/images/threejsBasics/camera2.png)
By default, the camera looks down the -Z axis with +Y up. If our mesh is positioned at the origin, we'd need to move the camera slightly back from the origin
to view anything.

#+BEGIN_SRC Javascript
camera.position.z = positive number;
#+END_SRC

**** Mesh
Mesh objects represent the pairing of specific Geometry with a Material. Both Material and Geometry can be associated with multiple Mesh objects.
#+BEGIN_SRC Javascript
    const cube = new THREE.Mesh(boxGeometry, material);
#+END_SRC
The cube example above demonstrates the constructor of a mesh, requiring a boxGeometry and a material object.

**** Geometry
Geometries symbolize the vertex data of objects like spheres, cubes, planes, animals, humans, trees, buildings, and more.
Three.js offers numerous built-in geometry primitives, but you can also create custom geometries or load geometries from files.

#+BEGIN_SRC Javascript
  // Data of a box
    const boxWidth = 1;
    const boxHeight = 1;
    const boxDepth = 1;
    const boxGeometry = new THREE.BoxGeometry(boxWidth, boxHeight, boxDepth);
#+END_SRC

**** Material
Materials depict the surface properties employed for drawing geometries.
This includes attributes like the color and shininess. A Material can also reference Texture objects, which can, for instance,
wrap an image onto a geometry's surface.

**** Texture
Textures typically symbolize images loaded from image files, generated from a canvas, or rendered from another scene.

**** Light
The Light object is relatively straightforward. Three.js has embedded types of light sources such as point light, ambient light, and directional light, among others.

*** Animation
Without it, the rendered content in the browser would just be a static 2D image. The browser provides a function called requestAnimationFrame
that forms a so-called render loop by accepting a drawing callback function. In essence, it continuously draws images frame-by-frame on the canvas.
Suppose your browser operates at 60 frames per second. That means it refreshes roughly every 16ms. When you invoke requestAnimationFrame(callback),
you're essentially making a request to the browser to execute the callback after this 16ms duration.
It's merely a reservation at this point, as requestAnimationFrame operates asynchronously and doesn't disrupt subsequent code execution.

#+BEGIN_SRC Javascript
    const animate = (currTime ) => {
        requestAnimationFrame(animate);
        cube.rotation.y += 0.01;
        renderer.render(scene, camera);
    }
    animate();
#+END_SRC

The code above demonstrates continuously rotating a cube around the y-axis.

*** Details
Lastly, a quick detail from the documentation to touch upon:
A canvas's internal size, often termed its drawing buffer size, can be set in three.js by calling renderer.setSize.
So, what size should we opt for? The obvious answer is "the same size the canvas is displayed".

Using my code as an example:
#+BEGIN_SRC Javascript
   const renderer = new THREE.WebGLRenderer({ antialias: true });
   renderer.setSize(window.innerWidth, window.innerHeight);
   document.body.appendChild(renderer.domElement); // domElement is the canvas returned from the renderer
#+END_SRC

When you call renderer.setSize(window.innerWidth, window.innerHeight), you're essentially instructing THREE.js: “I want the 3D content I'm rendering
to fill the entire browser window, and I'd like the size of the <canvas> element itself to be adjusted to this size.”
This ensures that your 3D content appears both clear and undistorted in the browser window.
** finished Functions in Kotlin
:PROPERTIES:
:EXPORT_FILE_NAME: functions-in-kotlin
:END:


- State "finished"   from              [2023-10-10 Tue 12:24]
In this post, I aim to summarize the essential aspects of function syntax in Kotlin. While this post touches upon some commonly used functionalities, especially in Android development,
it doesn't delve deep into the advanced usages.

*** Regular Functions
Regular functions are the basic building blocks. Here's a simple function that compares the lengths of two strings:

#+BEGIN_SRC kotlin
fun compare(a: String, b: String): Boolean {
    return a.length < b.length
}
#+END_SRC

It's necessary to specify the types of parameters. However, the return type can often be inferred by the compiler.

**** Default Arguments
Functions can have default values for their parameters. For instance:

#+BEGIN_SRC kotlin
fun compare(a: String = "hello", b: String = "hi"): Boolean {
    return a.length < b.length
}
#+END_SRC

This allows you to call the function as `compare()` or `compare("hi", "hello")`.

*** Single-expression Functions
For functions comprising just a single expression, you can drop the curly braces and use the `=` symbol:

#+BEGIN_SRC kotlin
fun double(x: Int): Int = x * 2
#+END_SRC

Moreover, if the compiler can infer the return type, you can omit it:

#+BEGIN_SRC kotlin
fun double(x: Int) = x * 2
#+END_SRC

*** Generic Functions
Generics enable functions to operate on different data types, ensuring code reusability and type safety.

#+BEGIN_SRC kotlin
fun <T> printMe(value: T) {
    println(value)
}

// You can call the function with any data type:
printMe("Hello")
printMe(25)
#+END_SRC

*** Lambdas
In Kotlin, functions are first-class, meaning they can be stored in variables, passed around, and returned from other functions.

**** Defining Function Types
Function types can be defined similar to other types:

#+BEGIN_SRC kotlin
val onClick: () -> Unit = { println("hello") }
#+END_SRC

Here, `onClick` is a variable of a function type. This function takes no arguments and returns `Unit` (similar to `void` in other languages).

**** Lambda Expressions
Lambda expressions, or simply lambdas, represent small chunks of code. They can be used primarily to define inline functions. The syntax is concise:

#+BEGIN_SRC 
val sum: (Int, Int) -> Int = { x, y -> x + y }
#+END_SRC

In this lambda:
- The expression is enclosed in curly braces.
- The parameter types can be omitted if they can be inferred.
- The lambda body follows the `->` symbol.
- If the return type isn't `Unit`, the last expression is taken as the return value.

**** Trailing Lambdas
A nifty Kotlin feature is the ability to move lambdas out of parentheses if they're the last argument in a function call:

#+BEGIN_SRC kotlin
fun foo(x: String, y: String, z: (a: String, b: String) -> Boolean) {
    println(z(x,y))
}
foo("hi", "hello") { a, b -> a.length < b.length }
#+END_SRC


** finished Fundamentals of Git
:PROPERTIES:
:EXPORT_FILE_NAME: fundamentals-of-git
:END:

- State "finished"   from              [2023-11-08 Wed 17:51]
Explore some essential aspects of the version control tool Git.

*** Concept
Initially, as a newcomer, I confused Git with GitHub (a platform), not realizing Git is fundamentally a local tool. Some refer to it as a version control tool, a file system, or even a database with key-value pairs.

To harness its capabilities, it's crucial to understand the primary command:
#+BEGIN_EXAMPLE
git init
#+END_EXAMPLE

This command will automatically create a .git folder for us under your working directory. The magic .git folder contains all the infomations of your local repo. If you delete it, your working
directory is not regarded as a git directory.

Let's dive into the .git folder. Below is my example, and I will mainly talk about the objetcs folder which contains all the commit objects, tree objetcs(directory) and blob objects(file content).

#+BEGIN_EXAMPLE

// all the files and sub folders under .git directory
-rw-r--r--@  1 tacodaddy  staff   35 Nov  8 10:58 COMMIT_EDITMSG
-rw-r--r--@  1 tacodaddy  staff   21 Nov  8 11:19 HEAD
-rw-r--r--   1 tacodaddy  staff   41 Feb 22  2023 ORIG_HEAD
-rw-r--r--   1 tacodaddy  staff  307 Feb 22  2023 config
-rw-r--r--   1 tacodaddy  staff   73 Feb 22  2023 description
drwxr-xr-x  15 tacodaddy  staff  480 Feb 22  2023 hooks
-rw-r--r--@  1 tacodaddy  staff  449 Nov  8 11:19 index
drwxr-xr-x   3 tacodaddy  staff   96 Feb 22  2023 info
drwxr-xr-x   4 tacodaddy  staff  128 Feb 22  2023 logs
drwxr-xr-x  31 tacodaddy  staff  992 Nov  8 10:58 objects
-rw-r--r--   1 tacodaddy  staff  112 Feb 22  2023 packed-refs
drwxr-xr-x   5 tacodaddy  staff  160 Feb 22  2023 refs

// part of the sub folders under .git/objects/
drwxr-xr-x@ 3 tacodaddy  staff   96 Nov  8 10:58 02
drwxr-xr-x  3 tacodaddy  staff   96 Feb 22  2023 06
drwxr-xr-x@ 3 tacodaddy  staff   96 Nov  8 10:58 07
drwxr-xr-x  3 tacodaddy  staff   96 Feb 22  2023 09
drwxr-xr-x  3 tacodaddy  staff   96 Feb 22  2023 19
#+END_EXAMPLE

Folders in objects are named using the first two characters of the 40-character SHA-1 hash of a Git object.
All Git objects, including blobs, trees, and commits, are uniquely identified by a 40-character hexadecimal string.

For instance, under folder 02, there's a file:
#+BEGIN_EXAMPLE
56b3b6f9d60a265d66a32bd3f238cd9f21d517

// combine 02 with the value above
0256b3b6f9d60a265d66a32bd3f238cd9f21d517

// and then decompress the file

❯ git cat-file -p 0256b3b6f9d60a265d66a32bd3f238cd9f21d517
tree 07fa58c37c411f8d9ffe9838af2b03735c845b31
parent 73ea321851ff2390c520a0cb8b2552efcae7852f
author Jeffery18-hub <ljzmcs@gmail.com> 1699466287 -0700
committer Jeffery18-hub <ljzmcs@gmail.com> 1699466287 -0700

modify test.text file, add Jeffery
#+END_EXAMPLE


This file under folder 02 is a commit object which is snapshot your project. Tree is the project structure which you can see by decompress.

#+BEGIN_EXAMPLE
❯ git cat-file -p 07fa58c37
100644 blob 259148fa18f9fb7ef58563f4ff15fc7b172339fb	.gitignore
100644 blob 066204b8085bbb3cc45baca943dcc6f31d9b3f91	README.md
100644 blob 09436c0302a7aca747cbe85936b74ed8aa760f60	helloFromMain.cpp
100644 blob 681c281095180933698877e8b3ee11bf42be546d	output.txt
100644 blob f4d7ea5e7bba9c9d92711770e0064ade060f9949	test.txt
#+END_EXAMPLE

The 'parent' tag indicates the preceding commit.
A common query: How can I determine if a document is a blob, tree, or commit?

#+BEGIN_EXAMPLE
git cat-file -t <sha1>
#+END_EXAMPLE

So `git cat-file` is a really useful command if you want to dig the rabbit hole of your project version history. Flag `-p` means pretty print and `-t` shows object type.


*** Fours Areas

Understanding the four key areas - working directory, staging area, local repository, and remote repository- is crucial.

`git add` moves changes to the staging area. `git commit` then commits these changes from staging to the local repository (located in the .git folder).

Committing creates a snapshot of your project, encompassing file contents, directory trees, and metadata like time and committer. It yields a commit object linking to your latest commit.

#+BEGIN_COMMENT
    |C|<------|B| <-------|A|
init commit           newst commit
#+END_COMMENT

Each commit acts like a node pointing to its predecessor.


*** Branches and Head

Different branches in Git means different pointers to versions.

![branches.png](/images/branches.png)

Creating a new branch is akin to creating a new pointer. When committing across multiple branches, how does Git know which branch to commit to? Here, the HEAD pointer comes into play.

HEAD typically points to the latest commit on the current branch but can be redirected to earlier commits if needed.

![head.png](/images/head.png)


*** Conclusion

While many tutorials offer Git commands, truly understanding Git requires diving beneath the surface.
A deeper comprehension of its inner workings can be invaluable in navigating complex scenarios.

** TODO Leetcode 198.House Robber
:PROPERTIES:
:EXPORT_FILE_NAME: leetcode-198-dot-house-robber
:END:


Here are two approaches to solving the classic "House Robber" problem: Recursion + Backtracking, and Iteration. Both methods apply dynamic programming effectively, albeit in different ways.

*** Solution One (Recursion + Backtracking)
This solution I found online (author: labuladong) uses recursion and backtracking. I am not sure if this counts as dynamic programming.

**** Basic Idea
1. Standing in front of the i-th house, the robber has two options: rob it and jump to the i + 2-th house to avoid being caught, or don’t rob it and move to the i + 1-th house.
2. Recursive function definition: The parameters are the nums array and the starting index. The return value is the maximum value that can be obtained from the starting index. The recursion stops when the index is greater than or equal to the length of nums, meaning there are no more houses.
3. Below, I drew a recursion tree based on the example -> nums = [1,2,3,1]. The green arrows represent robbing, the red arrows represent not robbing, the blue arrows represent returning values to the upper layer of recursion, and the black dashed circles represent exceeding the maximum index of the house, meaning such a node doesn’t exist.
   For the top node with a value of 1, you can see that the left tree returns a value of 3, and the right side also returns 3. So, at this initial stage, if the robber chooses to rob, the maximum value is 4, and if not, the maximum value is 3.
   [!tree1.png](/images/houseRobber/tree1.png)
4. The Python implementation is as follows:
   #+BEGIN_SRC python
      class Solution:
         def __init__(self):
	     self.memo = [] # memory list to avoid duplicate computing

         def rob(self, nums: List[int]) -> int:
	     if len(nums) == 1: 
	         return nums[0]

	     # initialize the memory list with values -1
	     self.memo = [-1] * len(nums)

	     return self.recursion(nums, 0)

         def recursion(self, nums, start):
	     if start > len(nums) - 1:
	         return 0

	     if self.memo[start] != -1: 
	         return self.memo[start]

	     res = max(self.recursion(nums, start + 2) + nums[start], 
		       self.recursion(nums, start + 1))

	     self.memo[start] = res

	     return res
   #+end_src 
5. From the Python code, you can see that it uses pruning. The purple marks in the diagram below show two identical nodes, which are the houses with a value of 3. If no pruning is done, the maximum value will be recalculated, increasing the complexity. Therefore, the code includes a memo array to check whether a node has been computed before. If it has, it directly returns the value without continuing recursion.
[!tree2.png](/images/houseRobber/tree2.png)


*** Solution Two (Iteration)
The solution I came up with myself seems more in line with the idea of dynamic programming (in my opinion). It is based on past states, establishes a state transition equation, and then deduces the current state, ultimately obtaining the maximum value through iteration.

**** Basic Idea
1. Standing at the current node, i.e., the i-th house, if the robber robs, then the adjacent left house cannot be robbed. The maximum value corresponding to the i-th house is based on the maximum value of the i - 2-th house; if not robbing, then the maximum value of the i-th house is based on the i - 1-th house.
2. Initialize the dp array, where dp[0] = nums[0], dp[1] = max(nums[1], dp[0]).
3. State transition equation: dp[i] = max(dp[i - 1], dp[i - 2] + nums[i]).
4. The final maximum value obtained is dp[len(nums) - 1].
The code is as follows:
#+BEGIN_SRC python
  class Solution:
    def rob(self, nums: List[int]) -> int:
        if len(nums) == 1: 
            return nums[0]

        dp = [0] * len(nums)
        dp[0] = nums[0]
        dp[1] = max(dp[0], nums[1])
        for i in range(2, len(nums)):
            dp[i] = max(dp[i - 1], dp[i - 2] + nums[i])
        
        return dp[-1]
#+END_SRC

I still prefer iteration because, firstly, the code is more concise, and secondly, it requires less space.


The English part of this blog is translated by chatGPT and below is the original Chinese version.

经典动态规划题目了，两种解决思路：

*** 解法一（递归 + 回溯）
这是我网上看到的题解（作者：labuladong），是采用递归和回溯的思路，但我不是很确定这是不是算作动态规划。

**** 基本思路
1. 强盗站在第i个house前，如果选择抢劫，为了避免被抓，就要跳到第i + 2个房间；不抢，则跳至第i + 1个房间。
2. 递归函数定义：参数一个是nums数组，一个是起始index， 返回值为基于起始index，能够获取的最大价值。 递归退出：在index大于等于nums的长度，返回0，也就是不存在对应的house了。
3. 下面我根据题目的例子[1,2,3,1], 手绘了递归树，其中绿色箭头表示rob，红色箭头表示不去rob，蓝色箭头表示向上一层递归返回值，黑色虚线圆圈表示超过了house最大index，不存在这样一个节点。
对于最顶层的值为1的节点，可以看到左树的返回值为3，右边同样为3，那么如果在这个起始阶段，robber选择抢劫的话，最大价值为4，不抢劫的话最大价值就为3。
[tree.png]()
4. python实现的代码如下
   #+BEGIN_SRC python
      class Solution:
     def __init__(self):
	 self.memo = [] # memory list to avoid duplicate computing

     def rob(self, nums: List[int]) -> int:
	 if len(nums) == 1: 
	     return nums[0]

	 # init the memory list with values -1
	 self.memo = [-1] * len(nums)

	 return self.recursion(nums, 0)

     def recursion(self, nums, start):
	 if start > len(nums) - 1:
	     return 0

	 if self.memo[start] != -1: 
	     return self.memo[start]

	 res = max(self.recursion(nums, start + 2) + nums[start], 
		     self.recursion(nums, start + 1))

	 self.memo[start] = res

	 return res
   #+end_src 
5. 从python代码可以看到其使用了剪支操作，下图紫色标记出来两个相同的节点，也就是价值为3的房子，如果不做任何剪支的话就会重复计算最大值，增加了复杂度，所以代码中加入了memo数组，用于判断该节点之前是否被计算过，如果计算过就直接返回，不再继续递归。

*** 解法二（迭代）
我自己想出来的题解比较符合动态规划思想（自我感觉），基于过去的状态，建立状态转移方程，进而推导出当前状态，最终通过迭代方式取得最大价值。

**** 基本思路
1. 站在当前节点，也就是说第i个house，robber如果抢劫，那么相邻左边的house就不能抢，第i个house对应的最大价值，是基于第i - 2的最大价值得来的；如果不抢劫，则第i个house对应的最大价值，是基于第i - 1个house得来的
1. 初始化dp数组，其中dp[0] = nums[0], dp[1] = max(nums[1], dp[0])
2. 状态转移方程： dp[i] = max(dp[i - 1], dp[i - 2]+ nums[i])
3. 最后求得的最大价值就是dp[len(nums) - 1]
代码如下：
#+BEGIN_SRC python
  class Solution:
    def rob(self, nums: List[int]) -> int:
        if len(nums) == 1: 
            return nums[0]

        dp = [0] * len(nums)
        dp[0] = nums[0]
        dp[1] = max(dp[0], nums[1])
        for i in range(2, len(nums)):
            dp[i] = max(dp[i - 1], dp[i - 2] + nums[i])
        
        return dp[-1]
#+END_SRC

我还是比较喜欢迭代，一是代码更加简洁，二是空间开销更少。




